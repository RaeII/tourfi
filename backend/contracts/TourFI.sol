// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/* 
████████╗ ██████╗ ██╗   ██╗██████╗ ███████╗██╗
╚══██╔══╝██╔═══██╗██║   ██║██╔══██╗██╔════╝██║
   ██║   ██║   ██║██║   ██║██████╔╝█████╗  ██║
   ██║   ██║   ██║██║   ██║██╔══██╗██╔══╝  ██║
   ██║   ╚██████╔╝╚██████╔╝██║  ██║██║     ██║
   ╚═╝    ╚═════╝  ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝
*/

import "./Payment.sol";

/// @title TourFI - Main contract that integrates travel and tourist management.
contract TourFI is Payment {

    address public treasury;
    
    // Structure to store booking details
    struct Booking {
        uint256 id;
        address traveler;
        uint256 amount;
        uint256 timestamp;
        bool isPaid;
        string metadataURI; // URI for additional booking metadata (can be an IPFS hash)
    }
    
    // Structure to return detailed payment information
    struct PaymentStatus {
        bool isPaid;          // General payment status
        bool existsInChain;   // If the booking exists on the blockchain
        bool paidInChain;     // If payment was registered in the base contract
        bool paidInRegistry;  // If marked as paid in the booking registry
        uint256 timestamp;    // Booking timestamp
        address traveler;     // Traveler's address
    }
    
    // Mapping from booking ID to booking details
    mapping(uint256 => Booking) public bookings;
    
    // Events
    event BookingCreated(uint256 indexed bookingId, address indexed traveler, uint256 amount);
    event BookingPaid(uint256 indexed bookingId, address indexed traveler, uint256 amount);
    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);
    event FundsTransferredToTreasury(uint256 amount);
    
    constructor(
        address _treasury,
        address _signerAddress,
        address _initialOwner
    ) Payment(_signerAddress, _initialOwner) {
        treasury = _treasury;
    }
    
    /// @notice Updates the treasury address
    /// @param _newTreasury New treasury address
    function updateTreasury(address _newTreasury) external onlyOwner {
        address oldTreasury = treasury;
        treasury = _newTreasury;
        emit TreasuryUpdated(oldTreasury, _newTreasury);
    }
    
    /// @notice Registers a new booking in the system
    /// @param bookingId Booking ID (from the backend)
    /// @param traveler Traveler's wallet address
    /// @param amount Booking value
    /// @param metadataURI Booking metadata URI
    function registerBooking(
        uint256 bookingId,
        address traveler,
        uint256 amount,
        string calldata metadataURI
    ) external onlyOwner {
        require(bookings[bookingId].timestamp == 0, "Booking already exists");
        
        bookings[bookingId] = Booking({
            id: bookingId,
            traveler: traveler,
            amount: amount,
            timestamp: block.timestamp,
            isPaid: false,
            metadataURI: metadataURI
        });
        
        emit BookingCreated(bookingId, traveler, amount);
    }
    
    /// @notice Processes the booking payment using the native token (BNB)
    /// @param bookingId Booking ID
    /// @param signature Signature generated by the backend
    function payBooking(
        uint256 bookingId,
        bytes calldata signature
    ) external payable {
        // Checks
        require(treasury != address(0), "Treasury not set");
        uint256 amount = msg.value;
        
        // Effects
        // Calls the internal payment processing function from the Payment contract
        _processPayment(bookingId, amount, msg.sender, signature);
        
        // Updates the booking status as paid
        if (bookings[bookingId].timestamp > 0) {
            bookings[bookingId].isPaid = true;
        }
        
        // Emits event before external interactions
        emit BookingPaid(bookingId, msg.sender, amount);
        
        // Interactions
        // Transfers funds to the treasury
        (bool success, ) = treasury.call{value: amount}("");
        require(success, "Transfer to treasury failed");
    }
    
    /// @notice Overrides the parent contract function to check if a booking has been paid
    /// @param bookingId Booking ID
    /// @return Boolean indicating if the booking has been paid
    function isBookingPaid(uint256 bookingId) public view override returns (bool) {
        return super.isBookingPaid(bookingId) || bookings[bookingId].isPaid;
    }
    
    /// @notice Implementation of the internal payment processing function
    /// @dev Overrides the parent contract function to add specific functionalities
    function _processPayment(
        uint256 bookingId,
        uint256 amount,
        address payer,
        bytes memory signature
    ) internal virtual override {
        // Calls the parent contract implementation
        super._processPayment(bookingId, amount, payer, signature);
        
        // Here we could add specific TourFI logic after payment processing
    }
    
    /// @notice Checks the detailed payment status of a booking
    /// @param bookingId Booking ID
    /// @return status Structure with detailed payment information
    function getBookingPaymentStatus(uint256 bookingId) external view returns (PaymentStatus memory status) {
        bool existsInRegistry = bookings[bookingId].timestamp > 0;
        bool paidInChain = super.isBookingPaid(bookingId);
        bool paidInRegistry = existsInRegistry && bookings[bookingId].isPaid;
        
        status = PaymentStatus({
            isPaid: paidInChain || paidInRegistry,
            existsInChain: existsInRegistry,
            paidInChain: paidInChain,
            paidInRegistry: paidInRegistry,
            timestamp: bookings[bookingId].timestamp,
            traveler: bookings[bookingId].traveler
        });
        
        return status;
    }
    
    /// @notice Gets the details of a booking
    /// @param bookingId Booking ID
    /// @return Booking details
    function getBookingDetails(uint256 bookingId) external view returns (Booking memory) {
        return bookings[bookingId];
    }
    
    /// @notice Sends all funds from the contract to the treasury
    function withdrawAllToTreasury() external onlyOwner nonReentrant {
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");
        require(treasury != address(0), "Treasury not set");
        
        // Emits event before transferring funds
        emit FundsTransferredToTreasury(balance);
        
        // Transfers funds
        (bool success, ) = treasury.call{value: balance}("");
        require(success, "Transfer to treasury failed");
    }
}
