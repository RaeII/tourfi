// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title Payment
 * @notice Contract for processing payments with native token (BNB)
 * @dev Uses signatures to authorize payments
 */
contract Payment is Ownable, ReentrancyGuard {
    using ECDSA for bytes32;
    using MessageHashUtils for bytes32;

    // Address of the authorized signatory to sign payment messages
    address public signerAddress;
    
    // Mapping to track already paid bookings
    mapping(uint256 => bool) public paidBookings;
    
    // Events
    event PaymentProcessed(uint256 indexed bookingId, address indexed payer, uint256 amount);
    event SignerUpdated(address indexed oldSigner, address indexed newSigner);
    event FundsWithdrawn(address indexed to, uint256 amount);
    
    // Errors
    error InvalidSignature();
    error BookingAlreadyPaid(uint256 bookingId);
    error InsufficientPayment(uint256 expected, uint256 provided);
    error WithdrawalFailed();
    
    /**
     * @dev Contract constructor
     * @param _signerAddress Address that will sign payment messages
     * @param initialOwner Address of the initial contract owner
     */
    constructor(
        address _signerAddress,
        address initialOwner
    ) Ownable(initialOwner) {
        signerAddress = _signerAddress;
    }
    
    /**
     * @dev Updates the signatory address
     * @param _newSigner New address that will be used to verify signatures
     */
    function updateSigner(address _newSigner) external onlyOwner {
        address oldSigner = signerAddress;
        signerAddress = _newSigner;
        emit SignerUpdated(oldSigner, _newSigner);
    }
    
    /**
     * @dev Verifies if the signature is valid for the provided parameters
     * @param bookingId Booking ID
     * @param amount Payment amount
     * @param payer Payer's address
     * @param signature Signature to be verified
     * @return true if the signature is valid
     */
    function verifySignature(
        uint256 bookingId,
        uint256 amount,
        address payer,
        bytes memory signature
    ) public view returns (bool) {
        
        // Reconstructing the hash identical to the backend
        // The backend uses: ethers.solidityPackedKeccak256(['uint256', 'uint256', 'address'], [bookingId, amountWei, walletAddress])
        // which is equivalent to keccak256(abi.encodePacked(...)) in Solidity
        bytes32 hash = keccak256(abi.encodePacked(bookingId, amount, payer));
        
        // Converting to Ethereum Signed Message format
        bytes32 ethSignedMessageHash = hash.toEthSignedMessageHash();
        
        // Recovering the address that signed the message
        address recoveredAddress = ethSignedMessageHash.recover(signature);
        
        // Verifying if the recovered address is equal to the authorized signatory
        return recoveredAddress == owner();
    }
    
    /**
     * @dev Checks if a specific booking has been paid
     * @param bookingId Booking ID to be checked
     * @return status Boolean indicating if the booking has been paid (true) or not (false)
     */
    function isBookingPaid(uint256 bookingId) public view virtual returns (bool status) {
        return paidBookings[bookingId];
    }
    
    /**
     * @dev Processes the payment using the native token (BNB) - Public function
     * @param bookingId Booking ID
     * @param signature Signature generated by the backend
     */
    function processPayment(
        uint256 bookingId,
        bytes memory signature
    ) public payable virtual nonReentrant {
        // Delegates to the internal function
        _processPayment(bookingId, msg.value, msg.sender, signature);
    }
    
    /**
     * @dev Internal implementation of payment processing
     * @param bookingId Booking ID
     * @param amount Payment amount
     * @param payer Payer's address
     * @param signature Signature generated by the backend
     */
    function _processPayment(
        uint256 bookingId,
        uint256 amount,
        address payer,
        bytes memory signature
    ) internal virtual {
        // Checks
        if (paidBookings[bookingId]) revert BookingAlreadyPaid(bookingId);
        
        // Verifies if the signature is valid
        if (!verifySignature(bookingId, amount, payer, signature)) {
            revert InvalidSignature();
        }
        
        // Effects
        // Marks the booking as paid before any external interaction
        paidBookings[bookingId] = true;
        
        // Emits payment processed event
        emit PaymentProcessed(bookingId, payer, amount);
    }
    
    /**
     * @dev Allows the owner to withdraw native funds from the contract
     * @param to Address to receive the funds
     * @param amount Amount of BNB to be withdrawn (in wei)
     */
    function withdrawFunds(
        address payable to,
        uint256 amount
    ) external onlyOwner nonReentrant {
        require(amount <= address(this).balance, "Insufficient contract balance");
        
        // Records the event before the transfer to avoid reentrancy
        emit FundsWithdrawn(to, amount);
        
        // Transfers the funds using call
        (bool success, ) = to.call{value: amount}("");
        if (!success) revert WithdrawalFailed();
    }
    
    /**
     * @dev Returns the current contract balance in BNB
     */
    function getContractBalance() external view returns (uint256) {
        return address(this).balance;
    }
    
    /**
     * @dev Fallback function to receive BNB
     */
    receive() external payable {}
    
    /**
     * @dev Fallback function for unknown calls
     */
    fallback() external payable {}
}
